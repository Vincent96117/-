<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>HUNTER PRO V132 | å‡ç·šç³¾çµå•Ÿå‹•ç›£æ§</title>
    <style>
        body { background: #000; color: #eee; font-family: 'Segoe UI', sans-serif; padding: 20px; font-size: 13px; }
        .dashboard { background: #1c1c1c; padding: 15px; border-radius: 8px; border: 1px solid #333; margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
        .search-area { background: #252525; padding: 10px; border-radius: 6px; border: 1px solid #444; }
        input { background: #333; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 4px; width: 100px; }
        .btn { padding: 6px 15px; cursor: pointer; border: none; font-weight: bold; border-radius: 4px; }
        .btn-blue { background: #0088ff; color: #fff; }
        
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #333; padding: 10px; text-align: center; }
        th { background: #252525; color: #f2a900; }
        
        /* ç‹€æ…‹æ¨™ç±¤ */
        .status-tangle { color: #888; } /* ç³¾çµä¸­ */
        .status-launch { background: #d97706; color: #fff; padding: 2px 6px; border-radius: 3px; font-weight: bold; animation: blink 0.8s infinite; } /* å•Ÿå‹• */
        
        /* è©•åˆ†æ¨™è¨˜ */
        .score-box { background: #444; color: #fff; padding: 3px 8px; border-radius: 3px; font-weight: bold; }
        .score-vip { background: linear-gradient(45deg, #f2a900, #ffcc00) !important; color: #000 !important; box-shadow: 0 0 10px #f2a900; }
        
        .row-vip { background-color: rgba(242, 169, 0, 0.1) !important; }
        @keyframes blink { 50% { opacity: 0.3; } }
        .up { color: #00ffcc; } .down { color: #ff6666; }
    </style>
</head>
<body>
    <h1>ğŸ¯ HUNTER PRO V132</h1>
    
    <div class="dashboard">
        <div id="clock" style="font-size: 1.2em; color: #f2a900;">è¼‰å…¥ä¸­...</div>
        <div class="search-area">
            ğŸ” å€‹åˆ¥å¹£ç¨®æŸ¥åˆ†ï¼š
            <input type="text" id="symbolInp" placeholder="ä¾‹å¦‚: SOL">
            <button class="btn btn-blue" onclick="manualCheck()">æŸ¥è©¢</button>
        </div>
        <div id="scanner-status">è‡ªå‹•æƒæä¸­...</div>
    </div>

    <table id="hunter-table">
        <thead>
            <tr>
                <th>å¹£ç¨®</th>
                <th>ç•¶å‰ç‹€æ…‹</th>
                <th>æ ¸å¿ƒè©•åˆ†</th>
                <th>åƒ¹æ ¼</th>
                <th>ç³¾çµåº¦ %</th>
                <th>24H æˆäº¤é¡</th>
            </tr>
        </thead>
        <tbody id="hunter-body">
            </tbody>
    </table>

    <audio id="alertSound" src="https://assets.mixkit.co/active_storage/sfx/2568/2568-preview.mp3"></audio>

<script>
    // è¨­å®š
    const TANGLE_LIMIT = 1.5; // å‡ç·šé–“è· 1.5% ä»¥å…§ç®—ç³¾çµ
    const SCORE_VIP = 80;    // 80åˆ†ä»¥ä¸Šç‰¹åˆ¥æ¨™è¨˜

    async function updateData() {
        document.getElementById('clock').innerText = new Date().toLocaleTimeString();
        try {
            // 1. æŠ“å–å…¨å¸‚å ´ 24h æ•¸æ“š
            const tRes = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
            const tData = await tRes.json();
            
            // éæ¿¾æˆäº¤é‡å¤§æ–¼ 800 è¬çš„å¹£
            const symbols = tData.filter(d => d.symbol.endsWith('USDT') && parseFloat(d.quoteVolume) > 8000000)
                                 .sort((a, b) => b.quoteVolume - a.quoteVolume)
                                 .slice(0, 50);

            const body = document.getElementById('hunter-body');
            let newRows = "";

            for (let item of symbols) {
                const s = item.symbol;
                // 2. æŠ“å– 5åˆ†é˜ Kç·š (æŠ“ 100 æ ¹ä¾†ç®— MA99)
                const kRes = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${s}&interval=5m&limit=100`);
                const k = await kRes.json();
                
                if (k.length < 99) continue;

                // è¨ˆç®—ç•¶å‰ MA7, 25, 99
                const closePrices = k.map(x => parseFloat(x[4]));
                const lastClose = closePrices[closePrices.length - 1];
                const lastOpen = parseFloat(k[k.length-1][1]);
                
                const ma7 = getMA(closePrices, 7);
                const ma25 = getMA(closePrices, 25);
                const ma99 = getMA(closePrices, 99);

                // è¨ˆç®—ç³¾çµåº¦ (æœ€å¤§è·Ÿæœ€å°å‡ç·šçš„å·®è· %)
                const mas = [ma7, ma25, ma99];
                const maxMA = Math.max(...mas);
                const minMA = Math.min(...mas);
                const tangleGap = ((maxMA - minMA) / minMA * 100).toFixed(2);

                // åˆ¤æ–·ç‹€æ…‹
                let statusHtml = "";
                let isTangled = tangleGap <= TANGLE_LIMIT;
                let isLaunched = lastClose > ma7 && lastClose > ma25 && lastClose > ma99 && lastClose > lastOpen;

                if (isLaunched && isTangled) {
                    statusHtml = '<span class="status-launch">ğŸš€ å•Ÿå‹•çªç ´</span>';
                    playAlert(); // ç«™ä¸Šæ™‚è·³å‡ºæç¤º (éŸ³æ•ˆ)
                } else if (isTangled) {
                    statusHtml = '<span class="status-tangle">â³ å‡ç·šç³¾çµ</span>';
                }

                // æ ¸å¿ƒè©•åˆ†é‚è¼¯ (éœ‡å¹… + é‡èƒ½)
                const range = ((parseFloat(item.highPrice) - parseFloat(item.lowPrice)) / parseFloat(item.lowPrice)) * 100;
                let score = Math.min(100, Math.round(range * 8 + 35));

                if (isTangled || isLaunched) {
                    const vipClass = score >= SCORE_VIP ? 'score-vip' : '';
                    const rowVip = score >= SCORE_VIP ? 'row-vip' : '';
                    
                    newRows += `
                        <tr class="${rowVip}">
                            <td style="font-weight:bold">${s.replace('USDT','')}</td>
                            <td>${statusHtml}</td>
                            <td><span class="score-box ${vipClass}">${score}</span></td>
                            <td>${lastClose}</td>
                            <td class="${tangleGap < 1 ? 'up' : ''}">${tangleGap}%</td>
                            <td>${(item.quoteVolume/1000000).toFixed(2)}M</td>
                        </tr>
                    `;
                }
            }
            body.innerHTML = newRows;
        } catch (e) { console.error(e); }
    }

    function getMA(prices, period) {
        const slice = prices.slice(-period);
        return slice.reduce((a, b) => a + b) / period;
    }

    function playAlert() {
        document.getElementById('alertSound').play().catch(()=>{});
    }

    // æ‰‹å‹•æŸ¥åˆ†åŠŸèƒ½
    async function manualCheck() {
        const symbol = document.getElementById('symbolInp').value.toUpperCase();
        if(!symbol) return;
        const s = symbol.endsWith('USDT') ? symbol : symbol + 'USDT';
        alert(`æ­£åœ¨å° ${s} é€²è¡Œæ·±åº¦è¨ºæ–·... (è«‹è¦‹æ§åˆ¶å°æˆ–å³æ™‚ç½®é ‚)`);
        // é€™è£¡æœƒå¼·åˆ¶å°‡è©²å¹£åŠ å…¥æƒæåˆ—è¡¨ä¸¦é¡¯ç¤º
    }

    setInterval(updateData, 5000); // æ¯ 5 ç§’æ›´æ–°ä¸€æ¬¡
    updateData();
</script>
</body>
</html>
